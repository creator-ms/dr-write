// This file is @generated by wasmcloud/weld-codegen 0.7.0.
// It is not intended for manual editing.
// namespace: app.drwrite

#[allow(unused_imports)]
use async_trait::async_trait;
#[allow(unused_imports)]
use serde::{Deserialize, Serialize};
#[allow(unused_imports)]
use std::{borrow::Borrow, borrow::Cow, io::Write, string::ToString};
#[allow(unused_imports)]
use wasmbus_rpc::{
    cbor::*,
    common::{
        deserialize, message_format, serialize, Context, Message, MessageDispatch, MessageFormat,
        SendOpts, Transport,
    },
    error::{RpcError, RpcResult},
    Timestamp,
};

#[allow(dead_code)]
pub const SMITHY_VERSION: &str = "1.0";

#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct DoiAck {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeslot: Option<u64>,
}

// Encode DoiAck as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_doi_ack<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &DoiAck,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(1)?;
    if let Some(val) = val.timeslot.as_ref() {
        e.str("timeslot")?;
        e.u64(*val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode DoiAck from cbor input stream
#[doc(hidden)]
pub fn decode_doi_ack(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<DoiAck, RpcError> {
    let __result = {
        let mut timeslot: Option<Option<u64>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct DoiAck, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        timeslot = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "timeslot" => {
                        timeslot = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        DoiAck {
            timeslot: timeslot.unwrap(),
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct DoiEvent {
    #[serde(default)]
    pub doi: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub folder: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prs: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub raw: Option<u64>,
    #[serde(default)]
    pub uid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

// Encode DoiEvent as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_doi_event<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &DoiEvent,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(6)?;
    e.str("doi")?;
    e.str(&val.doi)?;
    if let Some(val) = val.folder.as_ref() {
        e.str("folder")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.prs.as_ref() {
        e.str("prs")?;
        e.u64(*val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.raw.as_ref() {
        e.str("raw")?;
        e.u64(*val)?;
    } else {
        e.null()?;
    }
    e.str("uid")?;
    e.str(&val.uid)?;
    if let Some(val) = val.user.as_ref() {
        e.str("user")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode DoiEvent from cbor input stream
#[doc(hidden)]
pub fn decode_doi_event(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<DoiEvent, RpcError> {
    let __result = {
        let mut doi: Option<String> = None;
        let mut folder: Option<Option<String>> = Some(None);
        let mut prs: Option<Option<u64>> = Some(None);
        let mut raw: Option<Option<u64>> = Some(None);
        let mut uid: Option<String> = None;
        let mut user: Option<Option<String>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct DoiEvent, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => doi = Some(d.str()?.to_string()),
                    1 => {
                        folder = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    2 => {
                        prs = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    3 => {
                        raw = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    4 => uid = Some(d.str()?.to_string()),
                    5 => {
                        user = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "doi" => doi = Some(d.str()?.to_string()),
                    "folder" => {
                        folder = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "prs" => {
                        prs = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    "raw" => {
                        raw = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    "uid" => uid = Some(d.str()?.to_string()),
                    "user" => {
                        user = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        DoiEvent {
            doi: if let Some(__x) = doi {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field DoiEvent.doi (#0)".to_string(),
                ));
            },
            folder: folder.unwrap(),
            prs: prs.unwrap(),
            raw: raw.unwrap(),

            uid: if let Some(__x) = uid {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field DoiEvent.uid (#4)".to_string(),
                ));
            },
            user: user.unwrap(),
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct DoiNode {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub authors: Option<Names>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub by_user: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub containers: Option<Titles>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub create_day: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub create_month: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub create_year: Option<u64>,
    #[serde(default)]
    pub doi: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub editors: Option<Names>,
    #[serde(default)]
    pub folder: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub links: Option<Links>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pol_day: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pol_month: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pol_year: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pub_day: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pub_month: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pub_year: Option<u64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub publisher: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub summary: Option<String>,
    #[serde(default)]
    pub team: String,
    pub titles: Titles,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub typ: Option<String>,
}

// Encode DoiNode as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_doi_node<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &DoiNode,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(21)?;
    if let Some(val) = val.authors.as_ref() {
        e.str("authors")?;
        encode_names(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.by_user.as_ref() {
        e.str("by_user")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.containers.as_ref() {
        e.str("containers")?;
        encode_titles(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.create_day.as_ref() {
        e.str("create_day")?;
        e.u64(*val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.create_month.as_ref() {
        e.str("create_month")?;
        e.u64(*val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.create_year.as_ref() {
        e.str("create_year")?;
        e.u64(*val)?;
    } else {
        e.null()?;
    }
    e.str("doi")?;
    e.str(&val.doi)?;
    if let Some(val) = val.editors.as_ref() {
        e.str("editors")?;
        encode_names(e, val)?;
    } else {
        e.null()?;
    }
    e.str("folder")?;
    e.str(&val.folder)?;
    if let Some(val) = val.links.as_ref() {
        e.str("links")?;
        encode_links(e, val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.pol_day.as_ref() {
        e.str("pol_day")?;
        e.u64(*val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.pol_month.as_ref() {
        e.str("pol_month")?;
        e.u64(*val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.pol_year.as_ref() {
        e.str("pol_year")?;
        e.u64(*val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.pub_day.as_ref() {
        e.str("pub_day")?;
        e.u64(*val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.pub_month.as_ref() {
        e.str("pub_month")?;
        e.u64(*val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.pub_year.as_ref() {
        e.str("pub_year")?;
        e.u64(*val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.publisher.as_ref() {
        e.str("publisher")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.summary.as_ref() {
        e.str("summary")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    e.str("team")?;
    e.str(&val.team)?;
    e.str("titles")?;
    encode_titles(e, &val.titles)?;
    if let Some(val) = val.typ.as_ref() {
        e.str("typ")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode DoiNode from cbor input stream
#[doc(hidden)]
pub fn decode_doi_node(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<DoiNode, RpcError> {
    let __result = {
        let mut authors: Option<Option<Names>> = Some(None);
        let mut by_user: Option<Option<String>> = Some(None);
        let mut containers: Option<Option<Titles>> = Some(None);
        let mut create_day: Option<Option<u64>> = Some(None);
        let mut create_month: Option<Option<u64>> = Some(None);
        let mut create_year: Option<Option<u64>> = Some(None);
        let mut doi: Option<String> = None;
        let mut editors: Option<Option<Names>> = Some(None);
        let mut folder: Option<String> = None;
        let mut links: Option<Option<Links>> = Some(None);
        let mut pol_day: Option<Option<u64>> = Some(None);
        let mut pol_month: Option<Option<u64>> = Some(None);
        let mut pol_year: Option<Option<u64>> = Some(None);
        let mut pub_day: Option<Option<u64>> = Some(None);
        let mut pub_month: Option<Option<u64>> = Some(None);
        let mut pub_year: Option<Option<u64>> = Some(None);
        let mut publisher: Option<Option<String>> = Some(None);
        let mut summary: Option<Option<String>> = Some(None);
        let mut team: Option<String> = None;
        let mut titles: Option<Titles> = None;
        let mut typ: Option<Option<String>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct DoiNode, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        authors = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_names(d).map_err(|e| {
                                format!("decoding 'app.drwrite#Names': {}", e)
                            })?))
                        }
                    }
                    1 => {
                        by_user = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    2 => {
                        containers = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_titles(d).map_err(|e| {
                                format!("decoding 'app.drwrite#Titles': {}", e)
                            })?))
                        }
                    }
                    3 => {
                        create_day = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    4 => {
                        create_month = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    5 => {
                        create_year = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    6 => doi = Some(d.str()?.to_string()),
                    7 => {
                        editors = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_names(d).map_err(|e| {
                                format!("decoding 'app.drwrite#Names': {}", e)
                            })?))
                        }
                    }
                    8 => folder = Some(d.str()?.to_string()),
                    9 => {
                        links = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_links(d).map_err(|e| {
                                format!("decoding 'app.drwrite#Links': {}", e)
                            })?))
                        }
                    }
                    10 => {
                        pol_day = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    11 => {
                        pol_month = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    12 => {
                        pol_year = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    13 => {
                        pub_day = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    14 => {
                        pub_month = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    15 => {
                        pub_year = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    16 => {
                        publisher = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    17 => {
                        summary = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    18 => team = Some(d.str()?.to_string()),
                    19 => {
                        titles = Some(
                            decode_titles(d)
                                .map_err(|e| format!("decoding 'app.drwrite#Titles': {}", e))?,
                        )
                    }
                    20 => {
                        typ = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "authors" => {
                        authors = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_names(d).map_err(|e| {
                                format!("decoding 'app.drwrite#Names': {}", e)
                            })?))
                        }
                    }
                    "by_user" => {
                        by_user = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "containers" => {
                        containers = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_titles(d).map_err(|e| {
                                format!("decoding 'app.drwrite#Titles': {}", e)
                            })?))
                        }
                    }
                    "create_day" => {
                        create_day = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    "create_month" => {
                        create_month = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    "create_year" => {
                        create_year = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    "doi" => doi = Some(d.str()?.to_string()),
                    "editors" => {
                        editors = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_names(d).map_err(|e| {
                                format!("decoding 'app.drwrite#Names': {}", e)
                            })?))
                        }
                    }
                    "folder" => folder = Some(d.str()?.to_string()),
                    "links" => {
                        links = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(decode_links(d).map_err(|e| {
                                format!("decoding 'app.drwrite#Links': {}", e)
                            })?))
                        }
                    }
                    "pol_day" => {
                        pol_day = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    "pol_month" => {
                        pol_month = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    "pol_year" => {
                        pol_year = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    "pub_day" => {
                        pub_day = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    "pub_month" => {
                        pub_month = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    "pub_year" => {
                        pub_year = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    "publisher" => {
                        publisher = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "summary" => {
                        summary = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "team" => team = Some(d.str()?.to_string()),
                    "titles" => {
                        titles = Some(
                            decode_titles(d)
                                .map_err(|e| format!("decoding 'app.drwrite#Titles': {}", e))?,
                        )
                    }
                    "typ" => {
                        typ = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        DoiNode {
            authors: authors.unwrap(),
            by_user: by_user.unwrap(),
            containers: containers.unwrap(),
            create_day: create_day.unwrap(),
            create_month: create_month.unwrap(),
            create_year: create_year.unwrap(),

            doi: if let Some(__x) = doi {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field DoiNode.doi (#6)".to_string(),
                ));
            },
            editors: editors.unwrap(),

            folder: if let Some(__x) = folder {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field DoiNode.folder (#8)".to_string(),
                ));
            },
            links: links.unwrap(),
            pol_day: pol_day.unwrap(),
            pol_month: pol_month.unwrap(),
            pol_year: pol_year.unwrap(),
            pub_day: pub_day.unwrap(),
            pub_month: pub_month.unwrap(),
            pub_year: pub_year.unwrap(),
            publisher: publisher.unwrap(),
            summary: summary.unwrap(),

            team: if let Some(__x) = team {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field DoiNode.team (#18)".to_string(),
                ));
            },

            titles: if let Some(__x) = titles {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field DoiNode.titles (#19)".to_string(),
                ));
            },
            typ: typ.unwrap(),
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct DoiRequest {
    #[serde(default)]
    pub doi: String,
    #[serde(default)]
    pub folder: String,
    #[serde(default)]
    pub uid: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub user: Option<String>,
}

// Encode DoiRequest as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_doi_request<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &DoiRequest,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(4)?;
    e.str("doi")?;
    e.str(&val.doi)?;
    e.str("folder")?;
    e.str(&val.folder)?;
    e.str("uid")?;
    e.str(&val.uid)?;
    if let Some(val) = val.user.as_ref() {
        e.str("user")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode DoiRequest from cbor input stream
#[doc(hidden)]
pub fn decode_doi_request(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<DoiRequest, RpcError> {
    let __result = {
        let mut doi: Option<String> = None;
        let mut folder: Option<String> = None;
        let mut uid: Option<String> = None;
        let mut user: Option<Option<String>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct DoiRequest, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => doi = Some(d.str()?.to_string()),
                    1 => folder = Some(d.str()?.to_string()),
                    2 => uid = Some(d.str()?.to_string()),
                    3 => {
                        user = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "doi" => doi = Some(d.str()?.to_string()),
                    "folder" => folder = Some(d.str()?.to_string()),
                    "uid" => uid = Some(d.str()?.to_string()),
                    "user" => {
                        user = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        DoiRequest {
            doi: if let Some(__x) = doi {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field DoiRequest.doi (#0)".to_string(),
                ));
            },

            folder: if let Some(__x) = folder {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field DoiRequest.folder (#1)".to_string(),
                ));
            },

            uid: if let Some(__x) = uid {
                __x
            } else {
                return Err(RpcError::Deser(
                    "missing field DoiRequest.uid (#2)".to_string(),
                ));
            },
            user: user.unwrap(),
        }
    };
    Ok(__result)
}
pub type EventList = Vec<DoiEvent>;

// Encode EventList as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_event_list<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &EventList,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_doi_event(e, item)?;
    }
    Ok(())
}

// Decode EventList from cbor input stream
#[doc(hidden)]
pub fn decode_event_list(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<EventList, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<DoiEvent> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(
                    decode_doi_event(d)
                        .map_err(|e| format!("decoding 'app.drwrite#DoiEvent': {}", e))?,
                )
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<DoiEvent> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(
                        decode_doi_event(d)
                            .map_err(|e| format!("decoding 'app.drwrite#DoiEvent': {}", e))?,
                    ),
                }
            }
            arr
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct Link {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub app: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ctype: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cversion: Option<String>,
    #[serde(default)]
    pub url: String,
}

// Encode Link as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_link<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Link,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(4)?;
    if let Some(val) = val.app.as_ref() {
        e.str("app")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.ctype.as_ref() {
        e.str("ctype")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.cversion.as_ref() {
        e.str("cversion")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    e.str("url")?;
    e.str(&val.url)?;
    Ok(())
}

// Decode Link from cbor input stream
#[doc(hidden)]
pub fn decode_link(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<Link, RpcError> {
    let __result = {
        let mut app: Option<Option<String>> = Some(None);
        let mut ctype: Option<Option<String>> = Some(None);
        let mut cversion: Option<Option<String>> = Some(None);
        let mut url: Option<String> = None;

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct Link, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        app = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    1 => {
                        ctype = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    2 => {
                        cversion = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    3 => url = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "app" => {
                        app = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "ctype" => {
                        ctype = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "cversion" => {
                        cversion = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "url" => url = Some(d.str()?.to_string()),
                    _ => d.skip()?,
                }
            }
        }
        Link {
            app: app.unwrap(),
            ctype: ctype.unwrap(),
            cversion: cversion.unwrap(),

            url: if let Some(__x) = url {
                __x
            } else {
                return Err(RpcError::Deser("missing field Link.url (#3)".to_string()));
            },
        }
    };
    Ok(__result)
}
pub type Links = Vec<Link>;

// Encode Links as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_links<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Links,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_link(e, item)?;
    }
    Ok(())
}

// Decode Links from cbor input stream
#[doc(hidden)]
pub fn decode_links(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<Links, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<Link> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_link(d).map_err(|e| format!("decoding 'app.drwrite#Link': {}", e))?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<Link> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(
                        decode_link(d)
                            .map_err(|e| format!("decoding 'app.drwrite#Link': {}", e))?,
                    ),
                }
            }
            arr
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct Name {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub family: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub given: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub suffix: Option<String>,
}

// Encode Name as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_name<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Name,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(5)?;
    if let Some(val) = val.family.as_ref() {
        e.str("family")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.given.as_ref() {
        e.str("given")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.name.as_ref() {
        e.str("name")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.prefix.as_ref() {
        e.str("prefix")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    if let Some(val) = val.suffix.as_ref() {
        e.str("suffix")?;
        e.str(val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode Name from cbor input stream
#[doc(hidden)]
pub fn decode_name(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<Name, RpcError> {
    let __result = {
        let mut family: Option<Option<String>> = Some(None);
        let mut given: Option<Option<String>> = Some(None);
        let mut name: Option<Option<String>> = Some(None);
        let mut prefix: Option<Option<String>> = Some(None);
        let mut suffix: Option<Option<String>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct Name, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        family = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    1 => {
                        given = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    2 => {
                        name = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    3 => {
                        prefix = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    4 => {
                        suffix = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "family" => {
                        family = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "given" => {
                        given = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "name" => {
                        name = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "prefix" => {
                        prefix = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    "suffix" => {
                        suffix = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.str()?.to_string()))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        Name {
            family: family.unwrap(),
            given: given.unwrap(),
            name: name.unwrap(),
            prefix: prefix.unwrap(),
            suffix: suffix.unwrap(),
        }
    };
    Ok(__result)
}
pub type Names = Vec<Name>;

// Encode Names as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_names<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Names,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        encode_name(e, item)?;
    }
    Ok(())
}

// Decode Names from cbor input stream
#[doc(hidden)]
pub fn decode_names(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<Names, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<Name> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(decode_name(d).map_err(|e| format!("decoding 'app.drwrite#Name': {}", e))?)
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<Name> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(
                        decode_name(d)
                            .map_err(|e| format!("decoding 'app.drwrite#Name': {}", e))?,
                    ),
                }
            }
            arr
        }
    };
    Ok(__result)
}
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct TimeslotRequest {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timeslot: Option<u64>,
}

// Encode TimeslotRequest as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_timeslot_request<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &TimeslotRequest,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.map(1)?;
    if let Some(val) = val.timeslot.as_ref() {
        e.str("timeslot")?;
        e.u64(*val)?;
    } else {
        e.null()?;
    }
    Ok(())
}

// Decode TimeslotRequest from cbor input stream
#[doc(hidden)]
pub fn decode_timeslot_request(
    d: &mut wasmbus_rpc::cbor::Decoder<'_>,
) -> Result<TimeslotRequest, RpcError> {
    let __result = {
        let mut timeslot: Option<Option<u64>> = Some(None);

        let is_array = match d.datatype()? {
            wasmbus_rpc::cbor::Type::Array => true,
            wasmbus_rpc::cbor::Type::Map => false,
            _ => {
                return Err(RpcError::Deser(
                    "decoding struct TimeslotRequest, expected array or map".to_string(),
                ))
            }
        };
        if is_array {
            let len = d.fixed_array()?;
            for __i in 0..(len as usize) {
                match __i {
                    0 => {
                        timeslot = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }

                    _ => d.skip()?,
                }
            }
        } else {
            let len = d.fixed_map()?;
            for __i in 0..(len as usize) {
                match d.str()? {
                    "timeslot" => {
                        timeslot = if wasmbus_rpc::cbor::Type::Null == d.datatype()? {
                            d.skip()?;
                            Some(None)
                        } else {
                            Some(Some(d.u64()?))
                        }
                    }
                    _ => d.skip()?,
                }
            }
        }
        TimeslotRequest {
            timeslot: timeslot.unwrap(),
        }
    };
    Ok(__result)
}
pub type Titles = Vec<String>;

// Encode Titles as CBOR and append to output stream
#[doc(hidden)]
#[allow(unused_mut)]
pub fn encode_titles<W: wasmbus_rpc::cbor::Write>(
    mut e: &mut wasmbus_rpc::cbor::Encoder<W>,
    val: &Titles,
) -> RpcResult<()>
where
    <W as wasmbus_rpc::cbor::Write>::Error: std::fmt::Display,
{
    e.array(val.len() as u64)?;
    for item in val.iter() {
        e.str(item)?;
    }
    Ok(())
}

// Decode Titles from cbor input stream
#[doc(hidden)]
pub fn decode_titles(d: &mut wasmbus_rpc::cbor::Decoder<'_>) -> Result<Titles, RpcError> {
    let __result = {
        if let Some(n) = d.array()? {
            let mut arr: Vec<String> = Vec::with_capacity(n as usize);
            for _ in 0..(n as usize) {
                arr.push(d.str()?.to_string())
            }
            arr
        } else {
            // indefinite array
            let mut arr: Vec<String> = Vec::new();
            loop {
                match d.datatype() {
                    Err(_) => break,
                    Ok(wasmbus_rpc::cbor::Type::Break) => break,
                    Ok(_) => arr.push(d.str()?.to_string()),
                }
            }
            arr
        }
    };
    Ok(__result)
}
/// wasmbus.actorReceive
#[async_trait]
pub trait DoiService {
    async fn add_doi(&self, ctx: &Context, arg: &DoiNode) -> RpcResult<DoiNode>;
    async fn fetch_doi(&self, ctx: &Context, arg: &DoiRequest) -> RpcResult<DoiAck>;
    async fn query_events(&self, ctx: &Context, arg: &TimeslotRequest) -> RpcResult<EventList>;
}

/// DoiServiceReceiver receives messages defined in the DoiService service trait
#[doc(hidden)]
#[async_trait]
pub trait DoiServiceReceiver: MessageDispatch + DoiService {
    async fn dispatch(&self, ctx: &Context, message: Message<'_>) -> Result<Vec<u8>, RpcError> {
        match message.method {
            "AddDoi" => {
                let value: DoiNode = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'DoiNode': {}", e)))?;

                let resp = DoiService::add_doi(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(buf)
            }
            "FetchDoi" => {
                let value: DoiRequest = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'DoiRequest': {}", e)))?;

                let resp = DoiService::fetch_doi(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(buf)
            }
            "QueryEvents" => {
                let value: TimeslotRequest = wasmbus_rpc::common::deserialize(&message.arg)
                    .map_err(|e| RpcError::Deser(format!("'TimeslotRequest': {}", e)))?;

                let resp = DoiService::query_events(self, ctx, &value).await?;
                let buf = wasmbus_rpc::common::serialize(&resp)?;

                Ok(buf)
            }
            _ => Err(RpcError::MethodNotHandled(format!(
                "DoiService::{}",
                message.method
            ))),
        }
    }
}

/// DoiServiceSender sends messages to a DoiService service
/// client for sending DoiService messages
#[derive(Clone, Debug)]
pub struct DoiServiceSender<T: Transport> {
    transport: T,
}

impl<T: Transport> DoiServiceSender<T> {
    /// Constructs a DoiServiceSender with the specified transport
    pub fn via(transport: T) -> Self {
        Self { transport }
    }

    pub fn set_timeout(&self, interval: std::time::Duration) {
        self.transport.set_timeout(interval);
    }
}

#[cfg(not(target_arch = "wasm32"))]
impl<'send> DoiServiceSender<wasmbus_rpc::provider::ProviderTransport<'send>> {
    /// Constructs a Sender using an actor's LinkDefinition,
    /// Uses the provider's HostBridge for rpc
    pub fn for_actor(ld: &'send wasmbus_rpc::core::LinkDefinition) -> Self {
        Self {
            transport: wasmbus_rpc::provider::ProviderTransport::new(ld, None),
        }
    }
}
#[cfg(target_arch = "wasm32")]
impl DoiServiceSender<wasmbus_rpc::actor::prelude::WasmHost> {
    /// Constructs a client for actor-to-actor messaging
    /// using the recipient actor's public key
    pub fn to_actor(actor_id: &str) -> Self {
        let transport =
            wasmbus_rpc::actor::prelude::WasmHost::to_actor(actor_id.to_string()).unwrap();
        Self { transport }
    }
}
#[async_trait]
impl<T: Transport + std::marker::Sync + std::marker::Send> DoiService for DoiServiceSender<T> {
    #[allow(unused)]
    async fn add_doi(&self, ctx: &Context, arg: &DoiNode) -> RpcResult<DoiNode> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "DoiService.AddDoi",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: DoiNode = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': DoiNode", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    async fn fetch_doi(&self, ctx: &Context, arg: &DoiRequest) -> RpcResult<DoiAck> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "DoiService.FetchDoi",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: DoiAck = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': DoiAck", e)))?;
        Ok(value)
    }
    #[allow(unused)]
    async fn query_events(&self, ctx: &Context, arg: &TimeslotRequest) -> RpcResult<EventList> {
        let buf = wasmbus_rpc::common::serialize(arg)?;

        let resp = self
            .transport
            .send(
                ctx,
                Message {
                    method: "DoiService.QueryEvents",
                    arg: Cow::Borrowed(&buf),
                },
                None,
            )
            .await?;

        let value: EventList = wasmbus_rpc::common::deserialize(&resp)
            .map_err(|e| RpcError::Deser(format!("'{}': EventList", e)))?;
        Ok(value)
    }
}
